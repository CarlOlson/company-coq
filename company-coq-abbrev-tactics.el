;;; company-coq-abbrev-tactics.el --- Auto-extracted tactics

;;; Commentary:

;;; Code:

(defconst company-coq-auto-extracted-tactics
  '("Set Default Goal Selector @{selector}. "
    "Test Default Goal Selector. "
    "exact @{term}"
    "eexact @{term}"
    "assumption"
    "eassumption"
    "refine @{term}"
    "apply @{term}"
    "apply @{term} with @{term+}"
    "apply @{term} with (@{vref++} := @{term++}) "
    "apply @{term+}"
    "eapply @{term}"
    "simple apply @{term}"
    "lapply @{term}"
    "apply @{term} in @{ident}"
    "apply @{term} in @{ident}"
    "apply @{term} with @{bindinglist} in @{ident}"
    "eapply @{term} with @{bindinglist} in @{ident}"
    "apply @{term} with @{bindinglist} in @{ident} as @{intropattern}"
    "eapply @{term} with @{bindinglist} in @{ident} as @{intropattern}"
    "simple apply @{term} in @{ident}"
    "constructor @{num}"
    "constructor"
    "constructor @{num} with"
    "split"
    "exists @{bindinglist}"
    "exists @{bindinglist}"
    "left"
    "right"
    "left with @{bindinglist}"
    "right with @{bindinglist}"
    "split with @{bindinglist}"
    "econstructor"
    "eexists"
    "esplit"
    "eleft"
    "eright"
    "intro"
    "intros"
    "intro @{ident}"
    "intros @{ident+}"
    "intros until @{ident}"
    "intros until @{num}"
    "intro after @{ident}"
    "intro before @{ident}"
    "intro at top"
    "intro at bottom"
    "intro @{ident} after @{ident}"
    "intro @{ident} before @{ident}"
    "intro @{ident} at top"
    "intro @{ident} at bottom"
    "intros @{intropattern+}"
    "clear @{ident}"
    "clear @{ident+}"
    "clearbody @{ident}"
    "clear -@{ident+}"
    "clear"
    "clear dependent @{ident}"
    "revert @{ident+}"
    "revert dependent @{ident}"
    "move @{ident} after @{ident}"
    "move @{ident} before @{ident}"
    "move @{ident} at top"
    "move @{ident} at bottom"
    "rename @{ident} into @{ident}"
    "rename @{ident+} into @{ident+}"
    "set (@{ident} := @{term}) "
    "set (@{ident} := @{term}) in @{occgoalset}"
    "set (@{ident} @{binder} := @{term}) "
    "set @{term}"
    "set (@{ident} @{binder} := @{term}) in @{occgoalset}"
    "set @{term} in @{occgoalset}"
    "remember @{term} as @{ident}"
    "remember @{term} as @{ident} eqn:@{ident}"
    "remember @{term} as @{ident} in @{occgoalset}"
    "pose (@{ident} := @{term}) "
    "pose (@{ident} @{binder} := @{term}) "
    "pose @{term}"
    "decompose [@{qualid+}] @{term}"
    "decompose sum @{term}"
    "decompose record @{term}"
    "assert (@{ident} : @{form}) "
    "assert @{form}"
    "assert @{form} by @{tac}"
    "assert @{form} as @{intropattern}"
    "assert @{form} as @{intropattern} by @{tac}"
    "assert (@{ident} := @{term}) "
    "pose proof @{term} as @{intropattern}"
    "enough (@{ident} : @{form}) "
    "enough @{form}"
    "enough @{form} as @{intropattern}"
    "enough (@{ident} : @{form}) by @{tac}"
    "enough @{form} by @{tac}"
    "enough @{form} as @{intropattern} by @{tac}"
    "cut @{form}"
    "specialize (@{ident} @{term+}) "
    "specialize @{ident} with @{bindinglist}"
    "generalize @{term}"
    "generalize @{term+}"
    "generalize @{term} at @{num+}"
    "generalize @{term} as @{ident}"
    "generalize dependent @{term}"
    "evar (@{ident} : @{term}) "
    "instantiate (@{num} := @{term}) "
    "instantiate (@{num} := @{term}) in @{ident}"
    "instantiate (@{num} := @{term}) in (Value of @{ident}) "
    "instantiate (@{num} := @{term}) in (Type of @{ident}) "
    "instantiate"
    "admit"
    "absurd @{term}"
    "contradiction"
    "contradiction @{ident}"
    "contradict @{ident}"
    "exfalso"
    "destruct @{term}"
    "destruct @{term+}"
    "destruct @{term} as @{disjconjintropattern}"
    "destruct @{term} eqn:@{namingintropattern}"
    "destruct @{term} with @{bindinglist}"
    "edestruct @{term}"
    "destruct @{term} using @{term}"
    "destruct @{term} using @{term} with @{bindinglist}"
    "destruct @{term} in @{occgoalset}"
    "destruct @{term} with @{bindinglist} as @{disjconjintropattern} eqn:@{namingintropattern} using @{term} with @{bindinglist} in @{occgoalset}"
    "edestruct @{term} with @{bindinglist} as @{disjconjintropattern} eqn:@{namingintropattern} using @{term} with @{bindinglist} in @{occgoalset}"
    "in"
    "destruct! @{ident}"
    "case @{term}"
    "case @{term} with @{bindinglist}"
    "ecase @{term}"
    "ecase @{term} with @{bindinglist}"
    "simple destruct @{ident}"
    "simple destruct @{num}"
    "case_eq @{term}"
    "induction @{term}"
    "induction @{term} as @{disjconjintropattern}"
    "induction @{term} with @{bindinglist}"
    "einduction @{term}"
    "induction @{term} using @{term}"
    "induction @{term} using @{term} with @{bindinglist}"
    "induction @{term+} using @{qualid}"
    "induction @{term} in @{occgoalset}"
    "induction @{term} with @{bindinglist} as @{disjconjintropattern} using @{term} with @{bindinglist} in @{occgoalset}"
    "einduction @{term} with @{bindinglist} as @{disjconjintropattern} using @{term} with @{bindinglist} in @{occgoalset}"
    "induction! @{ident}"
    "elim @{term}"
    "elim @{term} with @{bindinglist}"
    "eelim @{term}"
    "elim @{term} using @{term}"
    "elim @{term} using @{term} with @{bindinglist}"
    "elim @{term} with @{bindinglist} using @{term} with @{bindinglist}"
    "eelim @{term} with @{bindinglist} using @{term} with @{bindinglist}"
    "elimtype @{form}"
    "simple induction @{ident}"
    "simple induction @{num}"
    "simple induction @{term}"
    "double induction @{ident} @{ident}"
    "double induction @{num} @{num}"
    "dependent induction @{ident}"
    "dependent induction @{ident} generalizing @{ident+}"
    "dependent destruction @{ident}"
    "functional induction (@{qualid} @{term+}) "
    "functional induction (@{qualid} @{term+}) as @{disjconjintropattern} using @{term} with @{bindinglist}"
    "discriminate @{term}"
    "discriminate @{num}"
    "discriminate @{term} with @{bindinglist}"
    "ediscriminate @{num}"
    "discriminate"
    "injection @{term}"
    "injection @{num}"
    "injection @{term} with @{bindinglist}"
    "einjection @{num}"
    "injection"
    "injection @{num} as @{intropattern+}"
    "injection as @{intropattern+}"
    "einjection @{num} as @{intropattern+}"
    "einjection as @{intropattern+}"
    "inversion @{ident}"
    "inversion @{num}"
    "inversion_clear @{ident}"
    "inversion @{ident} as @{intropattern}"
    "inversion @{num} as @{intropattern}"
    "inversion @{ident} in @{ident+}"
    "inversion @{ident} as @{intropattern} in @{ident+}"
    "inversion_clear @{ident} in @{ident+}"
    "dependent inversion @{ident}"
    "dependent inversion @{ident} as @{intropattern}"
    "dependent inversion_clear @{ident}"
    "dependent inversion_clear @{ident} as @{intropattern}"
    "dependent inversion @{ident} with @{term}"
    "dependent inversion @{ident} as @{intropattern} with @{term}"
    "dependent inversion @{ident} with @{term}"
    "dependent inversion_clear @{ident} with @{term}"
    "dependent inversion_clear @{ident} as @{intropattern} with @{term}"
    "simple inversion @{ident}"
    "simple inversion @{ident} as @{intropattern}"
    "inversion @{ident} using @{ident}"
    "inversion @{ident} using @{ident} in @{ident+}"
    "fix @{ident} @{num}"
    "cofix @{ident}"
    "cofix @{ident} with (@{ident++} @{binder++} : @{type++}) "
    "rewrite @{term}"
    "rewrite -> @{term}"
    "rewrite < -@{term}"
    "rewrite @{term} in @{clause}"
    "rewrite @{term} at @{occlist}"
    "rewrite @{term} by @{tac}"
    "rewrite @{term+}"
    "erewrite @{term}"
    "replace @{term} with @{term}"
    "replace @{term} with @{term} by @{tac}"
    "replace @{term}"
    "replace -> @{term}"
    "replace < -@{term}"
    "replace @{term} with @{term} in @{clause}"
    "replace @{term} with @{term} in @{clause} by @{tac}"
    "replace @{term} in @{clause}"
    "replace -> @{term} in @{clause}"
    "replace < -@{term} in @{clause}"
    "cutrewrite < - (@{term}= @{term}) "
    "cutrewrite -> (@{term}= @{term}) "
    "subst @{ident}"
    "subst @{ident+}"
    "stepl @{term}"
    "stepl @{term} by @{tac}"
    "stepr @{term}"
    "stepr @{term} by @{tac}"
    "Declare Right Step @{term}. "
    "change @{term}"
    "change @{term} with @{term}"
    "change @{term} at @{num+} with @{term}"
    "change @{term} in @{ident}"
    "change @{term} with @{term} in @{ident}"
    "change @{term} at @{num+} with @{term} in @{ident}"
    "cbv @{flag+}"
    "lazy @{flag+}"
    "compute"
    "compute"
    "cbv"
    "lazy"
    "compute [@{qualid+}] "
    "cbv [@{qualid+}] "
    "compute - [@{qualid+}] "
    "cbv - [@{qualid+}] "
    "lazy [@{qualid+}] "
    "lazy - [@{qualid+}] "
    "vm_compute"
    "native_compute"
    "red"
    "hnf"
    "cbn"
    "simpl"
    "cbn [@{qualid+}] "
    "cbn - [@{qualid+}] "
    "simpl @{pattern}"
    "simpl @{pattern} at @{num+}"
    "simpl @{qualid}"
    "simpl @{qstring}"
    "simpl @{qualid} at @{num+}"
    "simpl @{qstring} at @{num+}"
    "unfold @{qualid}"
    "unfold @{qualid+}"
    "unfold @{qstring}"
    "unfold @{qstring}%@{delimkey}"
    "fold @{term}"
    "fold"
    "pattern @{term}"
    "pattern @{term} at @{num+}"
    "pattern @{term} at -@{num+}"
    "pattern @{term+}"
    "pattern"
    "auto"
    "auto @{num}"
    "auto with @{ident+}"
    "auto with *"
    "auto using @{lemma+}"
    "auto using @{lemma+} with @{ident+}"
    "trivial"
    "trivial with @{ident+}"
    "trivial with *"
    "eauto"
    "autounfold with @{ident+}"
    "autounfold with @{ident+} in @{clause}"
    "autounfold with *"
    "autorewrite with @{ident+}"
    "autorewrite with @{ident+} using @{tac}"
    "autorewrite with @{ident+} in @{qualid}"
    "autorewrite with @{ident+} in @{qualid} using @{tac}"
    "autorewrite with @{ident+} in @{clause}"
    "Create HintDb @{ident} [discriminated] "
    "Hint @{hintdef} : @{ident+}"
    "Hint @{hintdef}"
    "Local Hint @{hintdef} : @{ident+}"
    "Local Hint @{hintdef}"
    "Resolve @{term}"
    "Resolve @{term+}"
    "Immediate @{term+}"
    "Constructors @{ident+}"
    "Unfold @{ident+}"
    "Hint @{hintdef}"
    "Hint Local @{hintdef} : @{ident+}"
    "Hint Local @{hintdef}"
    "Remove Hints @{term+} : @{ident+}"
    "Print Hint"
    "Print Hint @{ident}"
    "Print Hint *"
    "Print HintDb @{ident}"
    "Hint Rewrite @{term+} : @{ident+}"
    "Hint Rewrite -> @{term+} : @{ident+}"
    "Hint Rewrite < -@{term+} : @{ident+}"
    "Hint Rewrite @{term+} using @{tac} : @{ident+}"
    "Print Rewrite HintDb @{ident}"
    "Proof with @{tac}"
    "Proof with @{tac} using @{ident+}"
    "Proof using @{ident+} with @{tac}"
    "Declare Implicit Tactic @{tac}"
    "tauto"
    "intuition @{tac}"
    "intuition"
    "rtauto"
    "firstorder"
    "firstorder @{tac}"
    "firstorder with @{ident+}"
    "firstorder using @{qualid+}"
    "firstorder using @{qualid+} with @{ident+}"
    "congruence"
    "congruence @{n}"
    "congruence with @{term+}"
    "constr_eq @{term} @{term}"
    "unify @{term} @{term}"
    "unify @{term} @{term} with @{ident}"
    "is_evar @{term}"
    "has_evar @{term}"
    "is_var @{term}"
    "f_equal"
    "reflexivity"
    "symmetry"
    "symmetry in @{ident}"
    "transitivity @{term}"
    "decide equality"
    "compare @{term} @{term}"
    "simplify_eq @{term}"
    "simplify_eq @{num}"
    "simplify_eq"
    "esimplify_eq @{num}"
    "simplify_eq"
    "dependent rewrite -> @{ident}"
    "dependent rewrite < -@{ident}"
    "functional inversion @{ident}"
    "functional inversion @{num}"
    "functional inversion @{ident} @{qualid}"
    "quote @{ident}"
    "quote @{ident} [@{ident+}] "
    "classical_left"
    "classical_right"
    "btauto"
    "omega"
    "ring"
    "ring_simplify @{term+}"
    "field"
    "field_simplify @{term+}"
    "field_simplify_eq"
    "fourier"
    "cycle @{num}"
    "swap @{num} @{num}"
    "revgoals"
    "shelve"
    "Unshelve"
    "give_up"))

(provide 'company-coq-abbrev-tactics)
;;; company-coq-abbrev-tactics.el ends here
